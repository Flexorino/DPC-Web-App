/**
 * DPC-API
 * Die ist die REST-artige Schnittstelle, für das DPC-Projekt.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

import { ContextUpdateAnswer } from '../model/contextUpdateAnswer';
import { ContextUpdateRequest } from '../model/contextUpdateRequest';
import { InlineResponse2003 } from '../model/inlineResponse2003';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable({
  providedIn: 'root'
})
export class KontexteService {

    protected basePath = 'https://dia-pc.flexus.click/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }



    /**
     * Ehralte Kontexte für Zeitraum.
     * Es werden alle Kontexte für den ausgewählten Zeitraum zurückgegeben. Ist der KOntext für einen Zeitpunkt gewünscht sind End- und Startzeitpunkt gleich einzugeben. &lt;br&gt; Attribute der Kontexte weisen Redundanzen auf, auch wenn es sich um gleiche Attribute handelt. Es ist diese Aufgabe diese Redundanzen ggf. zu behandeln. &lt;br&gt; Falls es für einen Zeitraum keinen Nutzer spezifizierten Kontext gibt, so greigt der Root-Kontext ohne Gültigkeitszeitstempel. 
     * @param diaryId Die Id des Tagebuches.
     * @param from Ab welchen Zeitpunkt (Unix Timestamp)
     * @param to Bis welchen Zeitpunkt (Unix Timestamp)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getDiaryContexts(diaryId: string, from: number, to: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2003>;
    public getDiaryContexts(diaryId: string, from: number, to: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2003>>;
    public getDiaryContexts(diaryId: string, from: number, to: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2003>>;
    public getDiaryContexts(diaryId: string, from: number, to: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (diaryId === null || diaryId === undefined) {
            throw new Error('Required parameter diaryId was null or undefined when calling getDiaryContexts.');
        }
        if (from === null || from === undefined) {
            throw new Error('Required parameter from was null or undefined when calling getDiaryContexts.');
        }
        if (to === null || to === undefined) {
            throw new Error('Required parameter to was null or undefined when calling getDiaryContexts.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (from !== undefined && from !== null) {
            queryParameters = queryParameters.set('from', <any>from);
        }
        if (to !== undefined && to !== null) {
            queryParameters = queryParameters.set('to', <any>to);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        return this.httpClient.get<InlineResponse2003>(`${this.configuration.basePath}/diaries/${encodeURIComponent(String(diaryId))}/contexts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Aktualisiere einen Kontext
     * Falls kein expliziter Zeitpunkt angegeben wird, ist der aktualisierte Kontext ab jetzt gültig. &lt;br&gt; Es werden nur Attribute angegeben, die geändert werden sollen. Bei nicht erwähnten Attributen werden die Werte des Vorgängerkontexts übernommen. Das bedeutet auch, dass bei einer Löschung von Attributen, explizit ein null Wert gesetzt werde muss!
     * @param diaryId Die Id des Tagebuches.
     * @param contextUpdateRequest Eine Repräsentation der Kontextaktualisierung
     * @param from Ab welchen Zeitpunkt soll der Kontext gültig sein (Unix Timestamp)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateContext(diaryId: string, contextUpdateRequest: ContextUpdateRequest, from?: number, observe?: 'body', reportProgress?: boolean): Observable<ContextUpdateAnswer>;
    public updateContext(diaryId: string, contextUpdateRequest: ContextUpdateRequest, from?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ContextUpdateAnswer>>;
    public updateContext(diaryId: string, contextUpdateRequest: ContextUpdateRequest, from?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ContextUpdateAnswer>>;
    public updateContext(diaryId: string, contextUpdateRequest: ContextUpdateRequest, from?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (diaryId === null || diaryId === undefined) {
            throw new Error('Required parameter diaryId was null or undefined when calling updateContext.');
        }
        if (contextUpdateRequest === null || contextUpdateRequest === undefined) {
            throw new Error('Required parameter contextUpdateRequest was null or undefined when calling updateContext.');
        }

        let queryParameters = new HttpParams({encoder: this.encoder});
        if (from !== undefined && from !== null) {
            queryParameters = queryParameters.set('from', <any>from);
        }

        let headers = this.defaultHeaders;

        // to determine the Accept header
        const httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected !== undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<ContextUpdateAnswer>(`${this.configuration.basePath}/diaries/${encodeURIComponent(String(diaryId))}/contextUpdate`,
            contextUpdateRequest,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
